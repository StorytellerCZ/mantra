# Core Components

Here are the core components of Mantra and how they are organized:

## Client-Side Focus

Mantra gives special attention to the **client side** of your app. Mantra does not mix client and server code together; instead, it recommends code sharing. Here are the reasons why:

* Client side is where you put in a lot of effort. It's the biggest part of your codebase. Server-side codebase is relatively simpler to manage and organize.
* In the future, client-side apps will interact with the server using a schema. Client-side apps will have no idea how the server was implemented.
* Mantra [does not believe in Universal Apps](https://medium.com/kadira-voice/say-no-to-isomorphic-apps-b7b7c419c634). It encourages multiple apps for different platforms with code sharing and usage of PWA. Then it's common to have a single server to interact with a few client apps.

Based on the above factors, it's not a good idea to mix client and server code together.

**When we discuss Mantra further in this specification, it will be about the client side of your app.**

However, most of the apps will have server-side components. So, we have a directory layout for the server side as well. For that, refer to [Appendix B](#sec-Appendix-Server-Side-Directory-Layout).

## Modern EcmaScript

We rely on different features of modern EcmaScript/JavaScript and its module system. In order to use Mantra, you need to use at least [Meteor 1.3](https://forums.meteor.com/t/announcing-meteor-1-3-es2015-modules-app-testing-mobile-improvements-and-more/20182), which comes with an implementation of the ES2015 module system, but really you should be using Meteor 3+.

## React/Solid as the UI

We use React/Solid as the UI (presentation) layer in Mantra.

UI components should not know anything about the rest of the app and should not read or modify the application's state. Data and event handlers used to render the UI component should be passed in via props from containers or passed in as action props from inside event handlers. It is sometimes necessary to use temporary local state inside a UI component, but that state should never be referenced outside of its own component.

When writing your UI components, you can include any other component. Here are some places you can import components:

* Other UI components you define in your app.
* UI components from NPM (like material-ui).
* Any Containers in your app (we'll talk about this in a moment).

You can also import any library function and use them in the UI components. You can import them directly from NPM modules, but not from any Meteor packages. These functions should be [pure](https://en.wikipedia.org/wiki/Pure_function).

Here's a simple UI component:

```tsx
import React, { type FC } from 'react';

export const PostList: FC<{ posts: { _id: string; title: string }[] }> = ({posts}) => (
  <div className='postlist'>
    <ul>
      {posts.map(post => (
        <li key={post._id}>
          <a href={`/post/${post._id}`}>{post.title}</a>
        </li>
      ))}
    </ul>
  </div>
);
```

## Actions

Actions are where you write the **business logic** in your app. This includes:

* Validations
* State management
* Interacting with remote data sources

An action is a simple function that accepts the first argument as the whole [Application Context](#sec-Application-Context) in your app. Other arguments usually come when invoking the action.

Note: Inside an action, everything you do should be based on the Application Context and other arguments passed to the action. You should not import any ES2015 module except [libraries](#sec-Libraries). You should also avoid using Global variables inside actions.

Here are some actions:

```ts
import { FORM_ERROR } from 'react-final-form';

export default {
  create: ({ Meteor, navigate }) => async (title, content, complete) => {
    if (!title || !content) {
      complete({ [FORM_ERROR]: 'Title & Content are required!'})
    }
        
    return Meteor.callAsync('posts.create', title, content)
      .catch((error?: Meteor.Error) => {
          if (error) {
            complete({ [FORM_ERROR]: err.message})
          }
        })
      .then((id?: string) => {
          if (id) {
            complete()
            navigate(`/post/${id}`)
          }
        })
  },
};
```

## State Management

In an app, we need to deal with different kinds of states. We can divide them into two different categories:

1. Local State - State in the client-side app that will never be synced with a remote server (errors, validation messages, current page, display option).
2. Remote State - This is the state usually fetched from a remote server and synced with it.

We have different solutions for managing states in our app, including:

* React/Solid state (Local State)
* Meteor/MiniMongo (Remote State)
* Tracker/ReactiveDict (Local State)
* FlowRouter/react-router (Local State)
* Redux (Local State)
* GraphQL (Remote State)

This is where a lot of innovation is happening in the JavaScript community. So, Mantra is flexible when it comes to state management. You can use anything you want.

For example, you can use the following for your app when starting:

* Meteor/MiniMongo (Remote State)
* React/Solid state (Local State)
* react-router (Local State)

Later on you can move on to different solutions.

Note: However, Mantra enforces a few rules when managing your states.

* Any write operations to states should be done inside an action.
* You can read states in both actions and containers.
* You should not read or write into states directly inside UI components. UI components should know nothing about states in your app.
* React/Solid state can be completely managed in container component if it doesn't have any side effects.

[//]: # TODO examples

## Containers

Containers are the integration layer in Mantra. They perform these actions:

* Use state to modify variables and pass them into UI components via props.
* Pass actions into UI components.
* Pass items in Application Context into UI components.
* Pass context to actions.
* Retrieve any hooks or contexts and pass it into UI components.

A container is a React/Solid component. 

[//]: # (Containers are composed using [react-komposer]&#40;https://github.com/kadirahq/react-komposer&#41;. It supports different data sources, including Meteor/Tracker, Promises, Rx.js Observable, and nearly anything else.)

Normally, inside a container you need to write the following functions:

* Call any hooks and context
* Retrieve data
* Prepare any action methods

We have some rules when creating a container:

* There should be only one container component inside a single file.
* If you need to pass the Application Context to a component, do it via props.

Here's an example container:

```tsx
import React, { type FC } from 'react';
import { useParams } from 'react-router';
import { useSubscribe, useFind } from 'meteor/react-meteor-data';
import { PostList } from '../components/PostList.tsx';
import { Loader } from '/imports/core/components/Loader.tsx';
import { PostsCollection } from '/collections/posts';

export const PostListData: FC = () => {
  const { page } = useParams()
  const isLoading = useSubscribe('posts.list', page)
  const posts = useFind(() => PostsCollection.find())
  
  if (isLoading()) return <Loader />
  
  return <PostList posts={posts} />
}
```

## Routing & Component Mounting

Note: When we refer to components, we consider both containers and UI components.

We normally use a Router to mount components to the UI. There could be multiple solutions (for example, [Flow Router](https://github.com/veliovgroup/flow-router) and [React Router](https://reactrouter.com/)).

The Router's only functionality in Mantra is to mount components to the UI. It's just a tool.

See how to use FlowRouter as the router:

```js
import React from 'react';
import {FlowRouter} from 'meteor/kadira:flow-router';
import {mount} from 'react-mounter';

import MainLayout from '/client/modules/core/components/main_layout.jsx';
import PostList from '/client/modules/core/containers/postlist';

export default function (injectDeps) {
  const MainLayoutCtx = injectDeps(MainLayout);

  FlowRouter.route('/', {
    name: 'posts.list',
    action() {
      mount(MainLayoutCtx, {
        content: () => (<PostList />)
      });
    }
  });
}
```

> Note: If you need to redirect upon some condition (for example user is not authorized) use an action instead of route options like FlowRouter's triggersEnter. Call the action from component or container's composer function. In case of react-router you can use route components that check general access rights.


## Libraries

Every app has some utility functions to do different tasks. You can also get them via NPM. These libraries will export functions. So, you can import them anywhere in your app including inside actions, components, and containers.

> When using a library function inside a component, it should be [pure](https://en.wikipedia.org/wiki/Pure_function).

## Testing

[//]: # (TODO)

Testing is a core part of Mantra. Mantra helps you test every part of your application. Rules we've enforced will help you write those tests. You can use familiar tools such as [Mocha](https://mochajs.org/), [Chai](http://chaijs.com/), and [Sinon](http://sinonjs.org/) to perform testing.

With Mantra, you can unit test three core parts in your app. See:

* UI components - [Example](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/components/tests/post.js)
* Actions - [Example](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/actions/tests/posts.js)
* Container composers and deps mappers - [Example](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/tests/post.js)

### UI Testing

[//]: # (TODO Cypress and Storybook)
For the UI testing we use [enzyme](https://github.com/airbnb/enzyme). Click [here](https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/components/tests/post.js) to see some sample test cases.

## Mantra Modules

Mantra follows a modular architecture. All the components of Mantra should reside inside a module.

You can create as many as modules you like and communicate between them via imports.

### Application Context & Modules

Application context like Intl, user profile of the logged-in user and other should be provided via Context which should be built in the `core` module and put at the top of the router, so it is accessible to all the modules.

### Module Definition

In the past Mantra modules were self-initializing. We are moving away from the magic like approach to be more explicit so it is easier to track where is what coming from. The entry into a module in general should be via a `Router.tsx` in the root of the module that has a default export with the module routes.

> Note: Some modules can have a router that is designed to be a child of another module. For example comments module will have a router that can be included into any place where comments are needed. Into this router will be passed props like content type and content id, so that the module can operate easily. This will make the module re-usable in any parts that requires comments. 

### Implicit Modules

If the module has no actions or routes, or no need to do any initialization, then it's okay to avoid using a definition file or a router. These implicit modules may contain the following:

* UI components
* Containers
* Libraries

### Module Containers & UI Components

Module containers and UI components should be able to be imported via ES2015 modules.

### Module Actions

A module actions can be imported anywhere, but they should be primarily used in the module it was created in.

### Routes

For routing, you can use any routing library. It's okay to have route definitions inside multiple modules if needed.

### Core Module

Mantra is 100% modular and there should be a core in an app. We call this the core module. It's just a simple module. This module is the best place to put:

* core routes,
* application configurations,
* common libraries,
* common actions
* common components

and other application-specific code.

There are multiple ways to organize modules depending on the app. Refer to [Appendix C](#sec-Appendix-Organizing-Modules) for some of those methods.

### Sub Modules

Inside a module, you **cannot** have sub modules. This is a decision made to prevent unnecessary complexity. Otherwise, it's possible to write multiple layers of nested modules, and that's very hard to manage.

## Single Entry Point

With Mantra, we want our app to be predictable. Therefore, there is a single entry point in your app. That's the `client/main.jsx`.

It'll initialize the Application Context and load all the modules in your app. Here's an example `client/main.jsx` file:

```js
import { Meteor } from 'meteor/meteor';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { AppRouter } from '../imports/modules/core/AppRouter';

'use strict'

if (Meteor.isDevelopment) {
  // debugger
}

Meteor.startup(() => {
  const root = createRoot(document.getElementById('reactRoot'));

  root.render(<AppRouter />);
})
```
